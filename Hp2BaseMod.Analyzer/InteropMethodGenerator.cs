using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Hp2BaseMod.Analyzer
{
    [Generator(LanguageNames.CSharp)]
    public class InteropMethodGenerator : IIncrementalGenerator
    {
        private const string InteropMethodAttributeName = "InteropMethodAttribute";
        private const string Hp2BaseModPluginTypeName = "Hp2BaseModPlugin";

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            // Find all methods with InteropMethod attribute
            var interopMethods = context.SyntaxProvider.CreateSyntaxProvider(
                static (node, _) => node is MethodDeclarationSyntax method && method.AttributeLists.Count > 0,
                static (ctx, _) =>
                {
                    var methodDecl = (MethodDeclarationSyntax)ctx.Node;
                    var semanticModel = ctx.SemanticModel;
                    var methodSymbol = semanticModel.GetDeclaredSymbol(methodDecl) as IMethodSymbol;

                    if (methodSymbol == null || !HasInteropMethodAttribute(methodSymbol))
                        return default;

                    return (methodDecl, methodSymbol);
                })
                .Where(x => x.methodDecl != null);

            // Group by containing class
            var interopMethodsByClass = interopMethods.Collect()
                .Select((methods, _) =>
                {
                    return methods
                        .Where(x => x != default)
                        .GroupBy(x => x.methodSymbol.ContainingType, SymbolEqualityComparer.Default)
                        .ToImmutableArray();
                });

            context.RegisterSourceOutput(interopMethodsByClass, GenerateRegistration);
        }

        private static bool HasInteropMethodAttribute(IMethodSymbol method)
        {
            return method.GetAttributes().Any(attr =>
                attr.AttributeClass?.Name == InteropMethodAttributeName ||
                attr.AttributeClass?.Name == "InteropMethod");
        }

        private static void GenerateRegistration(
            SourceProductionContext context,
            ImmutableArray<IGrouping<ISymbol, (MethodDeclarationSyntax methodDecl, IMethodSymbol methodSymbol)>> groupedMethods)
        {
            foreach (var group in groupedMethods)
            {
                var containingType = (INamedTypeSymbol)group.Key;

                // Only generate for classes that inherit from Hp2BaseModPlugin
                if (!InheritsFromHp2BaseModPlugin(containingType))
                    continue;

                // Verify the class is partial
                if (!IsPartialClass(containingType))
                {
                    var diagnostic = Diagnostic.Create(
                        new DiagnosticDescriptor(
                            id: "HP008",
                            title: "Class must be partial",
                            messageFormat: "Class '{0}' contains InteropMethod methods but is not declared as partial. Add the 'partial' keyword to the class declaration.",
                            category: "Usage",
                            defaultSeverity: DiagnosticSeverity.Error,
                            isEnabledByDefault: true),
                        containingType.Locations.FirstOrDefault(),
                        containingType.Name);
                    context.ReportDiagnostic(diagnostic);
                    continue;
                }

                var source = GeneratePartialClass(containingType, group.ToList());
                var fileName = $"{containingType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithGlobalNamespaceStyle(SymbolDisplayGlobalNamespaceStyle.Omitted))}.InteropMethods.g.cs";
                fileName = fileName.Replace('<', '_').Replace('>', '_');

                context.AddSource(fileName, source);
            }
        }

        private static string GeneratePartialClass(
            INamedTypeSymbol containingType,
            List<(MethodDeclarationSyntax methodDecl, IMethodSymbol methodSymbol)> methods)
        {
            var sb = new StringBuilder();
            var namespaceName = containingType.ContainingNamespace?.ToDisplayString();

            // File header
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("#nullable enable");
            sb.AppendLine("using System;");
            sb.AppendLine();

            // Namespace
            if (!string.IsNullOrEmpty(namespaceName) && namespaceName != "<global namespace>")
            {
                sb.AppendLine($"namespace {namespaceName}");
                sb.AppendLine("{");
            }

            var indent = string.IsNullOrEmpty(namespaceName) || namespaceName == "<global namespace>" ? "" : "    ";

            // Class declaration
            sb.AppendLine($"{indent}partial class {containingType.Name}");
            sb.AppendLine($"{indent}{{");

            // Generate registration method override
            sb.AppendLine($"{indent}    /// <summary>");
            sb.AppendLine($"{indent}    /// Registers all InteropMethod-decorated methods with ModInterface.");
            sb.AppendLine($"{indent}    /// Called automatically by Hp2BaseModPlugin constructor.");
            sb.AppendLine($"{indent}    /// </summary>");
            sb.AppendLine($"{indent}    protected override void RegisterInteropMethods()");
            sb.AppendLine($"{indent}    {{");

            foreach (var (_, methodSymbol) in methods)
            {
                var methodName = methodSymbol.Name;
                var isStatic = methodSymbol.IsStatic;

                // Build parameter information
                var parameters = methodSymbol.Parameters;
                var paramTypes = parameters.Select(p =>
                    p.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)).ToList();

                // Build delegate type
                string delegateType;
                if (methodSymbol.ReturnsVoid)
                {
                    if (parameters.Length == 0)
                    {
                        delegateType = "global::System.Action";
                    }
                    else
                    {
                        delegateType = $"global::System.Action<{string.Join(", ", paramTypes)}>";
                    }
                }
                else
                {
                    var returnType = methodSymbol.ReturnType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    if (parameters.Length == 0)
                    {
                        delegateType = $"global::System.Func<{returnType}>";
                    }
                    else
                    {
                        delegateType = $"global::System.Func<{string.Join(", ", paramTypes)}, {returnType}>";
                    }
                }

                // Generate delegate creation
                sb.AppendLine($"{indent}        global::Hp2BaseMod.ModInterface.RegisterInterModValue(");
                sb.AppendLine($"{indent}            ModId,");
                sb.AppendLine($"{indent}            \"{methodName}\",");

                if (isStatic)
                {
                    // Static method - can reference directly with cast
                    sb.AppendLine($"{indent}            ({delegateType}){methodName});");
                }
                else
                {
                    // Instance method - create a delegate that captures 'this'
                    if (parameters.Length == 0)
                    {
                        // No parameters - use method group conversion
                        sb.AppendLine($"{indent}            new {delegateType}({methodName}));");
                    }
                    else
                    {
                        // Has parameters - create lambda with properly typed parameters
                        var paramDecls = parameters.Select((p, i) =>
                            $"p{i}").ToList();
                        var paramList = string.Join(", ", paramDecls);

                        sb.AppendLine($"{indent}            new {delegateType}(({paramList}) => {methodName}({paramList})));");
                    }
                }
                sb.AppendLine();
            }

            sb.AppendLine($"{indent}    }}");
            sb.AppendLine($"{indent}}}");

            // Close namespace
            if (!string.IsNullOrEmpty(namespaceName) && namespaceName != "<global namespace>")
            {
                sb.AppendLine("}");
            }

            return sb.ToString();
        }

        private static bool InheritsFromHp2BaseModPlugin(INamedTypeSymbol typeSymbol)
        {
            var currentType = typeSymbol.BaseType;
            while (currentType != null)
            {
                if (currentType.Name == Hp2BaseModPluginTypeName)
                    return true;
                currentType = currentType.BaseType;
            }
            return false;
        }

        private static bool IsPartialClass(INamedTypeSymbol typeSymbol)
        {
            return typeSymbol.DeclaringSyntaxReferences
                .Select(r => r.GetSyntax())
                .OfType<ClassDeclarationSyntax>()
                .Any(c => c.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword)));
        }
    }
}